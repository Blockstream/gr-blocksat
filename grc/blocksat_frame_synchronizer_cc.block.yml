# auto-generated by grc.converter

id: blocksat_frame_synchronizer_cc
label: Frame Synchronizer
category: '[Blockstream Satellite]/Synchronizers'

parameters:
-   id: preamble_syms
    label: Preamble Symbols
    dtype: complex_vector
-   id: frame_len
    label: Frame Length
    dtype: int
-   id: M
    label: Constellation Order
    dtype: int
    default: '2'
    options: ['2', '4']
    option_labels: [2 (BPSK), 4 (QPSK)]
    hide: none
-   id: n_success_to_lock
    label: Success to Lock
    dtype: int
-   id: en_eq
    label: Gain Scaling
    dtype: bool
    options: ['False', 'True']
    option_labels: [Disabled, Enabled]
-   id: en_phase_corr
    label: Phase Correction
    dtype: bool
    options: ['False', 'True']
    option_labels: [Disabled, Enabled]
-   id: en_freq_corr
    label: Freq. Correction
    dtype: bool
    options: ['False', 'True']
    option_labels: [Disabled, Enabled]
-   id: debug_level
    label: Debug Level
    dtype: int

inputs:
-   domain: stream
    dtype: complex
    vlen: 1

outputs:
-   domain: stream
    dtype: complex
    vlen: 1
-   label: pmf_out
    domain: stream
    dtype: complex
    vlen: 1
    optional: true
-   domain: message
    id: start_index
    optional: true

templates:
    imports: import blocksat
    make: |-
        blocksat.frame_synchronizer_cc(
          ${preamble_syms},
          ${frame_len},
          ${M},
          ${n_success_to_lock},
          ${en_eq},
          ${en_phase_corr},
          ${en_freq_corr},
          ${debug_level})
    callbacks:
    - get_mag_pmf_peak()
    - get_state()

documentation: |-
    Continuous-transmission Correlation-based Frame Synchronization


    Frame synchronization algorithm that relies on a filter matched to the preamble, known as "preamble matched filter" (PMF) in order to compute the cross-correlation between the received symbols and the preamble symbols known a priori.

    The block should be configured with a vector of preamble symbols that presents good correlation performance, namely a sequence of symbols that is highly correlated at lag 0 and presents negligible correlation for all other lags. For example, a Barker code sequence.

    Internally the cross-correlation is constantly computed and the peaks are inspected. All peaks exceeding the "Peak Detection Threshold" parameter are deemed as peaks, but the internal logic searches for the highest peak in case there are multiple peaks for one frame.
    The block keeps track of a sequence of peaks and, because it is configured with the frame length (given by both the preamble and payload lengths), it is able to compare whether the interval between detected peaks matches the expected interval (assuming continuous transmission). Once this is true for sufficiently long, the block infers that frame synchronization has been acquired.

    Finally, once frame synchronization lock is acquired, the block starts to output symbols. It can be configured either to 1) output both preamble and payload symbols or 2) solely payload symbols. The former alternative is used when the downstream blocks rely on the preamble for any data-aided processing, such as data-aided carrier phase correction.

    Note #1: An important remark is that the PMF can also be used for channel estimation. In fact, a single-tap channel estimator based on least-squares gives the exact same solution as the result of the peak yielded by the PMF. Nevertheless, note that, because there may be carrier frequency or phase offset affecting the incoming symbols, this channel estimation can be unreliable in terms of phase, although it may still be useful in order to obtain the channel gain. Hence, when the "Single-tap Equalization" parameter is enabled, only magnitude (channel gain) equalization is performed.

    Note #2: When observing the complex-valued PMF peak, it can be seen that the peak may be rotated in the complex plane. For example, when using two-dimensional preamble symbols, the peak may result in the real component and be positive (non-rotated case), but it may also appear for instance in the imaginary component as a negative peak (due to rotation). This rotation is inspected internally and can be used for phase correction, if the "Phase Correction" parameter is enabled.

file_format: 1
